# -*- coding: utf-8 -*-

"""
/***************************************************************************
 Q2_UE_exporter
                                 A QGIS plugin
 This plugin exports to UE compatible format
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2023-11-09
        copyright            : (C) 2023 by hannah g 
        email                : hannahgedlaman@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

__author__ = 'hannah g '
__date__ = '2023-11-09'
__copyright__ = '(C) 2023 by hannah g '

# This will get replaced with a git SHA1 when you do a git archive

__revision__ = '$Format:%H$'

import csv
from qgis.PyQt.QtCore import QCoreApplication
from qgis.core import (
    QgsProcessingParameterRasterLayer,
    QgsProcessingParameterFile,
    QgsProcessingParameterFolderDestination,
    QgsProcessingAlgorithm
)

import numpy as np
import rasterio
from rasterio.warp import calculate_default_transform, reproject, Resampling
from PIL import Image
import struct


# Set up the fuel model class
# The FuelMap will be made up of these
# This contains all of the data associated with a Fuel type
class FFuelModel:
    def __init__(self, fuel_load_1hr, fuel_load_10hr, fuel_load_100hr, fuel_load_live_herb, 
        fuel_load_live_woody, fuel_model_type, sav_ratio_dead_1hr, sav_ratio_live_herb, 
        sav_ratio_live_woody, fuel_bed_depth, dead_fuel_extinction_moisture, heat_content):
        self.fuel_load_1hr = fuel_load_1hr
        self.fuel_load_10hr = fuel_load_10hr
        self.fuel_load_100hr = fuel_load_100hr
        self.fuel_load_live_herb = fuel_load_live_herb
        self.fuel_load_live_woody = fuel_load_live_woody
        self.fuel_model_type = fuel_model_type
        self.sav_ratio_dead_1hr = sav_ratio_dead_1hr
        self.sav_ratio_live_herb = sav_ratio_live_herb
        self.sav_ratio_live_woody = sav_ratio_live_woody
        self.fuel_bed_depth = fuel_bed_depth
        self.dead_fuel_extinction_moisture = dead_fuel_extinction_moisture
        self.heat_content = heat_content

# LandFire data gives us fuel model data that needs to be translated to find the corresponding fire
# Scott and burgan ? data has ~ 40 fuel types
class FuelMap:
    def __init__(self):
        self.fuelModelTable ={ 
            91: FFuelModel(0.0, 0.0, 0.0, 0.0, 0.0, "NB (Open Water)", 0.0, 0.0, 0.0, 0.0, 0, 0),
            92: FFuelModel(0.0, 0.0, 0.0, 0.0, 0.0, "NB (Rock/Bare Ground)", 0.0, 0.0, 0.0, 0.0, 0, 0),
            93: FFuelModel(0.0, 0.0, 0.0, 0.0, 0.0, "NB", 0.0, 0.0, 0.0, 0.0, 0, 0),
            94: FFuelModel(0.0, 0.0, 0.0, 0.0, 0.0, "NB", 0.0, 0.0, 0.0, 0.0, 0, 0),
            95: FFuelModel(0.0, 0.0, 0.0, 0.0, 0.0, "NB", 0.0, 0.0, 0.0, 0.0, 0, 0),
            96: FFuelModel(0.0, 0.0, 0.0, 0.0, 0.0, "NB", 0.0, 0.0, 0.0, 0.0, 0, 0),
            97: FFuelModel(0.0, 0.0, 0.0, 0.0, 0.0, "NB", 0.0, 0.0, 0.0, 0.0, 0, 0),
            98: FFuelModel(0.0, 0.0, 0.0, 0.0, 0.0, "NB", 0.0, 0.0, 0.0, 0.0, 0, 0),
            99: FFuelModel(0.0, 0.0, 0.0, 0.0, 0.0, "NB", 0.0, 0.0, 0.0, 0.0, 0, 0),

            101: FFuelModel(0.10, 0.00, 0.00, 0.30, 0.00, "dynamic", 2200, 2000, 9999, 0.4, 15, 8000),
            102: FFuelModel(0.10, 0.00, 0.00, 1.00, 0.00, "dynamic", 2000, 1800, 9999, 1.0, 15, 8000),
            103: FFuelModel(0.10, 0.40, 0.00, 1.50, 0.00, "dynamic", 1500, 1300, 9999, 2.0, 30, 8000),
            104: FFuelModel(0.25, 0.00, 0.00, 1.90, 0.00, "dynamic", 2000, 1800, 9999, 2.0, 15, 8000),
            105: FFuelModel(0.40, 0.00, 0.00, 2.50, 0.00, "dynamic", 1800, 1600, 9999, 1.5, 40, 8000),
            106: FFuelModel(0.10, 0.00, 0.00, 3.40, 0.00, "dynamic", 2200, 2000, 9999, 1.5, 40, 9000),
            107: FFuelModel(1.00, 0.00, 0.00, 5.40, 0.00, "dynamic", 2000, 1800, 9999, 3.0, 15, 8000),
            108: FFuelModel(0.50, 1.00, 0.00, 7.30, 0.00, "dynamic", 1500, 1300, 9999, 4.0, 30, 8000),
            109: FFuelModel(1.00, 1.00, 0.00, 9.00, 0.00, "dynamic", 1800, 1600, 9999, 5.0, 40, 8000),

            121: FFuelModel(0.20, 0.00, 0.00, 0.50, 0.65, "dynamic", 2000, 1800, 1800, 0.9, 15, 8000),
            122: FFuelModel(0.50, 0.50, 0.00, 0.60, 1.00, "dynamic", 2000, 1800, 1800, 1.5, 15, 8000),
            123: FFuelModel(0.30, 0.25, 0.00, 1.23, 1.25, "dynamic", 1800, 1600, 1600, 1.8, 40, 8000),
            124: FFuelModel(1.90, 0.30, 0.10, 3.40, 7.10, "dynamic", 1800, 1600, 1600, 2.1, 40, 8000),
            # ...
            141: FFuelModel(0.25, 0.25, 0.00, 0.15, 1.30, "dynamic", 2000, 1800, 1600, 1.0, 15, 8000),
            142: FFuelModel(1.35, 2.40, 0.75, 0.00, 3.85, "N/A", 2000, 9999, 1600, 1.0, 15, 8000),
            143: FFuelModel(0.45, 3.00, 0.00, 0.00, 6.20, "N/A", 1600, 9999, 1400, 2.4, 40, 8000),
            144: FFuelModel(0.85, 1.15, 0.20, 0.00, 2.55, "N/A", 2000, 1800, 1600, 3.0, 30, 8000),
            145: FFuelModel(3.60, 2.10, 0.00, 0.00, 2.90, "N/A", 750, 9999, 1600, 6.0, 15, 8000),
            146: FFuelModel(2.90, 1.45, 0.00, 0.00, 1.40, "N/A", 750, 9999, 1600, 2.0, 30, 8000),
            147: FFuelModel(3.50, 5.30, 2.20, 0.00, 3.40, "N/A", 750, 9999, 1600, 6.0, 15, 8000),
            148: FFuelModel(2.05, 3.40, 0.85, 0.00, 4.35, "N/A", 750, 9999, 1600, 3.0, 40, 8000),
            149: FFuelModel(4.50, 2.45, 0.00, 1.55, 7.00, "dynamic", 750, 1800, 1500, 4.4, 40, 8000),

            161: FFuelModel(0.20, 0.90, 1.50, 0.20, 0.90, "dynamic", 2000, 1800, 1600, 0.6, 20, 8000),
            162: FFuelModel(0.95, 1.80, 1.25, 0.00, 0.20, "N/A", 2000, 9999, 1600, 1.0, 30, 8000),
            163: FFuelModel(1.10, 0.15, 0.25, 0.65, 1.10, "dynamic", 1800, 1600, 1400, 1.3, 30, 8000),
            164: FFuelModel(4.50, 0.00, 0.00, 0.00, 2.00, "N/A", 2300, 9999, 2000, 0.5, 12, 8000),
            165: FFuelModel(4.00, 4.00, 3.00, 0.00, 3.00, "N/A", 1500, 9999, 750, 1.0, 25, 8000),

            181: FFuelModel(1.00, 2.20, 3.60, 0.00, 0.00, "N/A", 2000, 9999, 9999, 0.2, 30, 8000),
            182: FFuelModel(1.40, 2.30, 2.20, 0.00, 0.00, "N/A", 2000, 9999, 9999, 0.2, 25, 8000),
            183: FFuelModel(0.50, 2.20, 2.80, 0.00, 0.00, "N/A", 2000, 9999, 9999, 0.3, 20, 8000),
            184: FFuelModel(0.50, 1.50, 4.20, 0.00, 0.00, "N/A", 2000, 9999, 9999, 0.4, 25, 8000),
            185: FFuelModel(1.15, 2.50, 4.40, 0.00, 0.00, "N/A", 2000, 9999, 1600, 0.6, 25, 8000),
            186: FFuelModel(2.40, 1.20, 1.20, 0.00, 0.00, "N/A", 2000, 9999, 9999, 0.3, 25, 8000),
            187: FFuelModel(0.30, 1.40, 8.10, 0.00, 0.00, "N/A", 2000, 9999, 9999, 0.4, 25, 8000),
            188: FFuelModel(5.80, 1.40, 1.10, 0.00, 0.00, "N/A", 1800, 9999, 9999, 0.3, 35, 8000),
            189: FFuelModel(6.65, 3.30, 4.15, 0.00, 0.00, "N/A", 1800, 9999, 1600, 0.6, 35, 8000),


        }

# The final array will be made up of instances of these
# This represents one point of data
# Everything but slope and elevation needs to be derived from the fuel map
class FireData:
    def __init__(self, elevation, fuelload1, fuelload10, fuelload100, fuelload1000, fueldepth, slope, fuel_sav):
        self.elevation = elevation
        self.fuelload1 = fuelload1
        self.fuelload10 = fuelload10
        self.fuelload100 = fuelload100
        self.fuelload1000 = fuelload1000

        self.fueldepth = fueldepth
        self.slope = slope
        self.fuel_sav = fuel_sav




class Q2_UE_exporterAlgorithm(QgsProcessingAlgorithm):
    """
    This is an example algorithm that takes a vector layer and
    creates a new identical one.

    It is meant to be used as an example of how to create your own
    algorithms and explain methods and variables used to do it. An
    algorithm like this will be available in all elements, and there
    is not need for additional work.

    All Processing algorithms should extend the QgsProcessingAlgorithm
    class.
    """

    # Constants used to refer to parameters and outputs. They will be
    # used when calling the algorithm from another algorithm, or when
    # calling from the QGIS console.

    OUTPUT = 'OUTPUT'
    INPUT = 'INPUT'
    TEXT_FILE ='TEXT_FILE'

    def initAlgorithm(self, config):
        """
        Here we define the inputs and output of the algorithm, along
        with some other properties.
        """

        # We add the input vector features source. It can have any kind of
        # geometry.
        self.addParameter(
            QgsProcessingParameterRasterLayer(
                self.INPUT,
                self.tr('Input layer'),
                optional=False,
            )
        )

          # Text File Selection
        self.addParameter(
            QgsProcessingParameterFile(
                self.TEXT_FILE,
                self.tr('Select Georeferencing Text File'),
                behavior=QgsProcessingParameterFile.File,  # Use .File for single file selection
                fileFilter='Text files (*.txt)',  # Filter to only show text files
                optional=False
            )
        )

        # We add a feature sink in which to store our processed features (this
        # usually takes the form of a newly created vector layer when the
        # algorithm is run in QGIS).
        self.addParameter(
            QgsProcessingParameterFolderDestination(
                self.OUTPUT,
                self.tr('Output Destination')
            )
        )


        # this function is for resizing the raster to have UE compatible dimensions
    def calculate_closest_dimensions(self,input_width, input_length):
    # Define possible section sizes in vertices
        section_sizes_vertices = [7, 15, 31, 63, 127, 255]
        sections_per_component = [1]
        params = []


 

    # Iterate over possible section sizes in quads
        for vertice_size in section_sizes_vertices:
            for section in sections_per_component:
            # Calculate the number of components needed based on the input dimensions
                component_size = vertice_size * section
                num_components_width = -(-input_width // component_size)  # This is a "ceiling" division
                num_components_length = -(-input_length // component_size)
            
                if num_components_length <= 32 and num_components_width <= 32:
                # Calculate the overall resolution in vertices
                    overall_resolution_width = num_components_width * component_size + 1
                    overall_resolution_length = num_components_length * component_size + 1

                # If the calculated resolution meets the criteria, return it
                    if overall_resolution_width >= input_width and overall_resolution_length >= input_length:
                        params.append(vertice_size)
                        params.append(section)
                        params.append(vertice_size)
                        return overall_resolution_width, overall_resolution_length, params

        print("Unable to find a valid configuration for the given dimensions.")
        return None, None
    
        # This will change the data to fit the compatible dimensions
    def resample_band_data(self, band_data, new_width, new_height):
        padded = np.full((new_height, new_width), -1, dtype=band_data.dtype)  # Use 0 for padding
        masked = np.full((new_height, new_width), -1, dtype=band_data.dtype)  # Use 0 for padding

        padded[:band_data.shape[0], :band_data.shape[1]] = band_data
        masked[:band_data.shape[0], :band_data.shape[1]] = 255.0

        return padded, masked
    
   
    
        # this function will convert the tif band to a heightmap (a png.)
    def convert_image_band(self, img_data, output_filename, new_width, new_height, params, output_directory):
        img_data = np.array(img_data)



        if len(img_data.shape) > 2:
            img_data = np.mean(img_data, axis=2)

        img_data = np.where(img_data < 0, 0, img_data)

    

        # Now pad the data before normalization
        img_data_padded, resampled_mask = self.resample_band_data(img_data, new_width, new_height)

        # Scale binary mask values from 1 to 255
        mask_image = Image.fromarray(resampled_mask.astype('uint8'))

        output_filename1 = output_directory + "/bounds.png"

            # Save the image
        mask_image.save(output_filename1, format='PNG')
    

    # Separate actual data from sentinel values
        actual_data = np.where(img_data_padded != -1, img_data_padded, -1)  # Check for 0 as padding


    # Flatten the array and find unique elements
        unique_values = np.unique(actual_data.ravel())

    # Sort the unique values
        sorted_unique_values = np.sort(unique_values)

    # Extract the minimum and second minimum
        second_min_val = sorted_unique_values[1] if len(sorted_unique_values) > 1 else None


    



    # Normalize only the actual data
        min_val = actual_data.min()
        range_val = actual_data.max() - second_min_val
        normalized_data = ((actual_data - second_min_val) / range_val * 65534).astype(np.uint16) + 1
        

      # Calculate the Z-scale for Unreal Engine
        ue_default_range = 512  # 512 meters (+/- 256m) for 100% Z-scale
        z_scale_percentage = (range_val *100/ ue_default_range)/30
        params.append(z_scale_percentage)
        # Apply the sentinel value in the 16-bit range
        img_data_16bit = np.where(img_data_padded != -1, normalized_data, -1)  # Using 0 for sentinel in 16-bit

    # Flatten the array and find unique elements
        unique_values = np.unique(img_data_16bit.ravel())

        # Sort the unique values
        sorted_unique_values = np.sort(unique_values)

        # Extract the minimum and second minimum
        min_val = sorted_unique_values[0]
        second_min_val = sorted_unique_values[1] if len(sorted_unique_values) > 1 else None
        third_min_val = sorted_unique_values[2] if len(sorted_unique_values) > 2 else None


        # Now you can continue with the rest of the processing
        img_16bit = Image.fromarray(img_data_16bit)
        img_16bit.save(output_filename, format="PNG")

        return params

        #this is the function called to process the selected file or layer
        # right now it is tailored specifically to LandFire data. 
    
    import numpy as np
    from PIL import Image




    def process_geotiff(self, input_filename, output_directory):
       

        with rasterio.open(input_filename) as src:
            elevation_array = None
            slope_array = None
                # for each band in the raster.. 
            for band_index in range(1, src.count + 1):

                # ... processing logic for

                
            
                new_width, new_height, params  = self.calculate_closest_dimensions(src.width, src.height)


                band_data = src.read(band_index).squeeze()


                # elevation data is the first band (for the landfire use case)
                if(band_index==1):
                    elevation_array = band_data
                     # ... rest of your existing code ...
                    output_directory1 = f"{output_directory}/elevation.png"
                    params = self.convert_image_band(band_data, output_directory1, new_width, new_height, params, output_directory)
                    output_filename = f"{output_directory}/elevation.csv"

                    self.write_csv(params,output_filename)
                    # and then slope
                if(band_index==2):
                    slope_array = band_data
                         # ... rest of your existing code ...
                    output_directory1 = f"{output_directory}/slope.png"
                
                    params = self.convert_image_band(band_data, output_directory1, new_width, new_height, params, output_directory)
                    output_filename = f"{output_directory}/slope.csv"

                    self.write_csv(params,output_filename)

                    # fuel model is band 4 so we have tp extract the wanted data from the fuel map
                if(band_index==4):
                    fuel_map = FuelMap()

                    unique = np.unique(band_data)

                        # Initialize arrays
                    fuel_load_1hr_array = np.zeros_like(band_data, dtype=np.float64)
                    fuel_load_10hr_array = np.zeros_like(band_data, dtype=np.float64)
                    fuel_load_100hr_array = np.zeros_like(band_data, dtype=np.float64)
                    fuel_load_1000hr_array = np.zeros_like(band_data, dtype=np.float64) # Assuming you have data for this
                    fuel_depth_array = np.zeros_like(band_data, dtype=np.float64)
                    fuel_sav_array = np.zeros_like(band_data, dtype=np.float64)
                    fire_data_grid = []
                    count_minus_9999 = 0

                    # Process and populate arrays
                    for i in range(band_data.shape[0]):
                        row = []
                        for j in range(band_data.shape[1]):
                            fuel_model_number = band_data[i, j]
                            if (fuel_model_number==-9999):
                                count_minus_9999+=1

                                fuel_load_1hr_array[i, j] = 0.0
                                fuel_load_10hr_array[i, j] = 0.0
                                fuel_load_100hr_array[i, j] = 0.0
                                fuel_load_1000hr_array[i, j] = 0.0  # Example assignment
                                fuel_depth_array[i, j] = 0.0
                                fuel_sav_array[i, j] = 0.0  # Example assignment
                            else:
                                fuel_model = fuel_map.fuelModelTable.get(fuel_model_number)
                                fuel_load_1hr_array[i, j] = fuel_model.fuel_load_1hr
                                fuel_load_10hr_array[i, j] = fuel_model.fuel_load_10hr
                                fuel_load_100hr_array[i, j] = fuel_model.fuel_load_100hr
                                fuel_load_1000hr_array[i, j] = fuel_model.fuel_load_live_herb  # Example assignment
                                fuel_depth_array[i, j] = fuel_model.fuel_bed_depth
                                fuel_sav_array[i, j] = fuel_model.sav_ratio_dead_1hr  # Example assignment

                            fire_data_instance = FireData(
                            elevation=elevation_array[i,j],
                            fuelload1=fuel_load_1hr_array[i, j],  # or choose appropriate fuel load array
                            fuelload10=fuel_load_10hr_array[i, j],  # or choose appropriate fuel load array
                            fuelload100=fuel_load_100hr_array[i, j],  # or choose appropriate fuel load array
                            fuelload1000=fuel_load_1000hr_array[i, j],  # or choose appropriate fuel load array
                            fueldepth=fuel_depth_array[i, j],
                            slope = slope_array[i,j],
                            fuel_sav=fuel_sav_array[i, j]
                            )
                            row.append(fire_data_instance)
                        fire_data_grid.append(row)

                    # Calculate the total number of elements
                    total_elements = band_data.size

                    #   Calculate the percentage of -9999 instances
                    percentage_minus_9999 = (count_minus_9999 / total_elements) * 100

                    # Log the result

                    # defome fuel_data_arrays as a dictionary with array names as keys
                    fuel_data_arrays = {
                        "fuel_load_1hr": fuel_load_1hr_array,
                        "fuel_load_10hr": fuel_load_10hr_array,
                        "fuel_load_100hr": fuel_load_100hr_array,
                        "fuel_load_1000hr": fuel_load_1000hr_array,  # Adjust as needed
                        "fuel_depth": fuel_depth_array,
                        "fuel_sav": fuel_sav_array
                        }

                    for array_name, array in fuel_data_arrays.items():

                        output_directory1 = f"{output_directory}/{array_name}.png"
                        params = self.convert_image_band(array, output_directory1, new_width, new_height, params, output_directory)
                        output_filename = f"{output_directory}/{array_name}.csv"
                        self.write_csv(params,output_filename)
                    

                else:
                    continue

                # write data to binary to be loaded into unreal engine as a 'lossless' data format
                import struct

                binary_data = bytearray()

            # New lines to get dimensions of the grid
                num_rows = len(fire_data_grid)
                num_cols = len(fire_data_grid[0]) if num_rows > 0 else 0


            # Pack and prepend the dimensions to the binary data
                binary_data += struct.pack('2Q', num_rows, num_cols)  # '2Q' for two unsigned long longs

                for row in fire_data_grid:
                    for data in row:
                    #64 bit 
                        binary_data += struct.pack('8d', data.elevation, data.fuelload1,data.fuelload10,data.fuelload100,data.fuelload1000, data.fueldepth, data.slope, data.fuel_sav)

                    # Write to a binary file
                binary_file_path = f"{output_directory}/lossless.bin"


                with open(binary_file_path, 'wb') as file:
                    file.write(binary_data)
                            

    def extract_numeric_values(self, text):
        import re
        # Find all numeric values, possibly including decimals and negatives
        return re.findall(r"-?\d+\.?\d*", text)
    

    def process_reference_file(self, input_filename, output_directory):
        import os
        # Path to the original text file containing the raster information

        # Path for the new CSV file to write the extracted information
        output_csv_path = os.path.join(output_directory, "georef_info.csv")


        # Function to extract numeric values from text
       

        # Read the original text file
        with open(input_filename, 'r') as file:
            lines = file.readlines()

        # Prepare data for CSV
        data_for_csv = []
        for line in lines:
            if ":" in line:
                key, value = line.split(":", 1)
                # Extract numeric value(s)
                numeric_values = self.extract_numeric_values(value)
                if numeric_values:
                # Assuming there's only one numeric value per line
                    data_for_csv.append({'Parameter': key.strip(), 'Value': numeric_values[0]})

            # Write the extracted data to a new CSV file
            with open(output_csv_path, 'w', newline='') as csvfile:
                fieldnames = ['Parameter', 'Value']
                writer = csv.DictWriter(csvfile, fieldnames=fieldnames)
                writer.writeheader()
                for item in data_for_csv:
                    writer.writerow(item)

            print(f"Extracted data has been written to {output_csv_path}")
        

           


    def write_csv(self, params, output_directory):
       

        # Write the data to the CSV file
        with open(output_directory, mode='w', newline='') as csv_file:
            writer = csv.writer(csv_file)
   
            # Write the params as a single row
            for param in params:
                writer.writerow([param])




    def processAlgorithm(self, parameters, context, feedback):
        """
        Here is where the processing itself takes place.
        """

        # Retrieve input and output file paths from parameters
        input_layer = self.parameterAsRasterLayer(parameters, self.INPUT, context)
        output_directory = self.parameterAsFile(parameters, self.OUTPUT, context)

        # Get the path to the selected raster file
        input_file = input_layer.source()

        # Process the geotiff file
        self.process_geotiff(input_file, output_directory)
        georef_text_file_path = self.parameterAsFile(parameters, self.TEXT_FILE, context)

        self.process_reference_file(georef_text_file_path, output_directory)


        #  return an empty dictionary.
        return {}

       
    def name(self):
        """
        Returns the algorithm name, used for identifying the algorithm. This
        string should be fixed for the algorithm, and must not be localised.
        The name should be unique within each provider. Names should contain
        lowercase alphanumeric characters only and no spaces or other
        formatting characters.
        """
        return 'Export to UE format'

    def displayName(self):
        """
        Returns the translated algorithm name, which should be used for any
        user-visible display of the algorithm name.
        """
        return self.tr(self.name())

    def group(self):
        """
        Returns the name of the group this algorithm belongs to. This string
        should be localised.
        """
        return self.tr(self.groupId())

    def groupId(self):
        """
        Returns the unique ID of the group this algorithm belongs to. This
        string should be fixed for the algorithm, and must not be localised.
        The group id should be unique within each provider. Group id should
        contain lowercase alphanumeric characters only and no spaces or other
        formatting characters.
        """
        return ''

    def tr(self, string):
        return QCoreApplication.translate('Processing', string)

    def createInstance(self):
        return Q2_UE_exporterAlgorithm()
